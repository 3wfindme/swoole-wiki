# Coroutine\Channel::select

通道读写检测。类似于`socket_select`和`stream_select`可以检测`channel`是否可进行读写。

原型
----
```php
function Coroutine\Channel::select(array &$read, array &$write, float $timeout = 0);
```

当`$read`或`$write`数组中有部分`channel`对象处于可读或可写状态，`select`会立即返回，不会产生协程调度。当数组中没有任何`channel`可读或可写时，将挂起当前协程，并设置定时器。当其中一个通道可读或可写时，将重新唤醒当前协程。

`select`操作只检测`channel`列表的可读或可写状态，但并不会读写`channel`，在`select`调用返回后，可遍历`$read`和`$write`数组，执行`pop`和`push`方法，完成通道读写操作。

参数
----
* `$read` 数组引用类型，元素为`channel`对象，读操作检测，可以为`null`
* `$write` 数组引用类型，元素为`channel`对象，写操作检测，可以为`null`
* `$timeout` 浮点型，超时设置，单位为秒，最小粒度为`0.001`秒，即`1ms`。默认为`0`，表示永不超时。

返回值
----
* 成功返回`true`，底层会修改`$read`、`$write`数组，`$read`和`$write`中的元素，即是可读或可写的`channel`
* 超时或传入的参数错误，如`$read`和`$write`中有非`channel`对象，底层返回`false`


实例
----
```php
$c1 = new chan(3);
$c2 = new chan(2);
$c3 = new chan(2);
$c4 = new chan(2);

$c3->push(3);
$c3->push(3.1415);

$c4->push(3);
$c4->push(3.1415);

go(function () use ($c1, $c2, $c3, $c4) {
    echo "select\n";
    for ($i = 0; $i < 1; $i++)
    {
        $read_list = [$c1, $c2];
        $write_list = [$c3, $c4];
        // $write_list = null;
        $result = chan::select($read_list, $write_list, 5);
        var_dump($result, $read_list, $write_list);

        foreach($read_list as $ch)
        {
            var_dump($ch->pop());
        }

        foreach($write_list as $ch)
        {
            var_dump($ch->push(666));
        }
        echo "exit\n";
    }
});

go(function () use ($c3, $c4) {
    co::sleep(1);
    $data = $c3->pop();
    var_dump($data);
});

go(function () use ($c1, $c2) {
	co::sleep(1);
	$c1->push("resume");
	$c2->push("hello");
});
```